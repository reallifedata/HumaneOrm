{   
#indent "off"
module Lexer
open Parser
open System   
open Microsoft.FSharp.Text.Lexing
 
let newline (lexbuf: LexBuffer<_>) = 
	lexbuf.StartPos <- lexbuf.StartPos.NextLine
 
let keywords =   
	[   
		"SELECT", SELECT;   
		"FROM", FROM;   
		"WHERE", WHERE;   
		"ORDER", ORDER;   
		"BY", BY;   
		"JOIN", JOIN;   
		"INNER", INNER;   
		"LEFT", LEFT;   
		"RIGHT", RIGHT;   
		"ASC", ASC;   
		"DESC", DESC;   
		"AND", AND;   
		"OR", OR;   
		"ON", ON;   
	] |> Map.ofList   
 
let ops =   
	[   
		"=",    EQ;   
		"<",    LT;   
		"<=",   LE;   
		">",    GT;   
		">=",   GE;   
	] |> Map.ofList   
}   
 
let char        = ['a'-'z' 'A'-'Z']   
let digit       = ['0'-'9']   
let int         = '-'?digit+   
let float       = '-'?digit+ '.' digit+   
let identifier  = char(char|digit|['-' '_' '.'])*   
let whitespace  = [' ' '\t']   
let newline     = "\n\r" | '\n' | '\r'  
let operator    = ">" | ">=" | "<" | "<=" | "="  
 
rule tokenize = parse   
| whitespace    { tokenize lexbuf }   
| newline       { lexbuf.EndPos <- lexbuf.EndPos.NextLine; tokenize lexbuf; }   
| int           { INT(Int32.Parse(LexBuffer<int>.LexemeString lexbuf)) }   
| float         { FLOAT(Double.Parse(LexBuffer<float>.LexemeString lexbuf)) }   
| operator      { ops.[LexBuffer<string>.LexemeString lexbuf] }   
| identifier    { match keywords.TryFind(LexBuffer<string>.LexemeString lexbuf) with   
					| Some(token) -> token   
					| None -> ID(LexBuffer<string>.LexemeString lexbuf) }   
| ','           { COMMA }   
| eof           { EOF }
